# 目录结构 
基本上还是按buckyos的目录结构来，以最大限度的复用目录和配置文件

## 基本设计
增加 $BUCKYOS_ROOT/local/bin 目录，下面放的是安装在本机的应用（运行时不依赖buckyos的存在)
$BUCKYOS_ROOT/bin目录和 $BUCKYOS_ROOT/local/bin 目录的区别
- $BUCKYOS_ROOT/bin 目录的内容，受到zone/node_config的影响。用户通过zone/node_id 可以指定设备下的该目录的应用程序版本进行管理
- $BUCKYOS_ROOT/local/bin 目录的内容，只受到$BUCKYOS_ROOT/local/etc 下配置的影响（单机配置），但大部分时候，通用组件都会配置成使用 $BUCKYOS_ROOT/bin 下的版本（使用最新版本）。这个机制依赖pkg-env的实现。


## 运行起来的感觉
下面列出的是安装在$BUCKYOS_ROOT/local/bin 目录下的pkg-id

### app-daemon
安装了buckyos-app的机器，会设置成默认开机启动，用来守护其它需要持续允许的native app service
根据配置 启动cyfs-gateway+buckyos-bakcup-suite
app-daemon也包含了本平台的托盘图标？
app-daemon也基于pkg基础设施，对$BUCKYOS_ROOT/local/bin 目录下的pkg进行自动升级
### buckyos-app
桌面快捷方式指向该应用

### cyfs-gateway
一般复用 $BUCKYOS_ROOT/bin 下的

### buckyos-backup-suite
native app的典型结构是 service + webui (这种结构不docker化，必须是system-app)
该pkg-id是service,一般复用$BUCKYOS_ROOT/bin 下的，服务运行后会自己挂webui folder

## 一些常见操作
### native-app安装配置
如果native-app有服务，则需要修改 $BUCKYOS_ROOT/local/etc/下的配置，让app-daemon可以自动启动服务
native-app安装后配置中包含启动url和必要的meta info

### 启动native-app
根据appid得到安装配置，根据meta-info创建(复用)该app的native-runtime,然后传递启动url.应用在独立窗口中运行
也可以在浏览器中运行，由app自行处理web-runtime和native-runtime的区别

### native-app开发中，对系统的依赖？
原理上只能依赖cyfs-gateway,以及native-runtime等基础组件。

## 不安装buckyos-service
不安装buckyos-service,会导致系统只有 $BUCKYOS_ROOT/local/ 目录


